<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="../../dist/reset.css">
		<link rel="stylesheet" href="../../dist/reveal.css">
		<link rel="stylesheet" href="../../dist/theme/black.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="../../plugin/highlight/monokai.css">
		<style>
			.reveal {
				background-color: black
			}
		</style>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h4> Session vs Token Based Authentication </h4>
				</section>
				<section>
					<iframe width="1000" height="650" src="https://www.youtube.com/embed/UBUNrFtufWo">
					</iframe>
				</section>
				<section>
					<section>
						<h4>Session</h4>
					</section>
					<section id="fragments">
						<p>1. The user sends a login request to the server.</p>
						<p class="fragment">2. The server authenticates the login request, sends a session to the database, and returns a cookie containing the session ID to the user.</p>
						<p class="fragment">3. Now, the user sends new requests (with a cookie).</p>
						<p class="fragment">4. The server checks in the database for the ID found in the cookie, if the ID is found it sends the requested pages to the user.</p>
					</section>
					<section>
						<img src="../../assets/session-based-authentication.png" style="height: 650px; width: 1000px;">
					</section>
					<section>
						<p>What are the pros and cons with this approch? </p>
					</section>
					<section id="fragments">
						<h4>pros</h4>
						<p class="fragment">Since sessions are stored on the server, its administrators are in power over them and the can immediately invalidate they session ID </p>
					</section>
					<section>
						<h4> cons </h4>
						<p class="fragment">scalability problems</p>
						<p class="fragment"> cross-site request forgery attacks</p>
						<p class="fragment"> man-in-the-middle attack </p>
					</section>
				</section>
				<section>
					<section>
						<h4>Token-Based Authentication</h4>
					</section>
					<section id="fragments">
						<p>1. The user sends a login request to the server.</p>
						<p class="fragment">2. The server authorizes the login and sends a token to the user.</p>
						<p class="fragment">3. Now, the user sends a new request(with a token).</p>
						<p class="fragment">4. The server checks the token is valid or not, if the token is valid it sends the requested pages to the user.</p>
					</section>
					<section>
						<img src="../../assets/token-based-authentication.png" style="height: 650px; width: 1000px;">
					</section>
					<section>
						<p>What are the pros and cons with this approch? </p>
					</section>
					<section id="fragments">
						<h4>pros</h4>
						<p class="fragment">servers that use tokens can improve their performances, because they do not need to continuously look through all the session details to authorize the user's requests.</p>
					</section>
					<section id="fragments">
						<h4>cons</h4>
						<p class="fragment">If a hypothetical attacker manages to get a valid token, they may have unlimited access to the server databases.</p>
					</section>
				</section>
				<section>
					<h4>Differences Between Session and Token-Based Authentication Methods</h4>
					<img src="../../assets/Differences-Between-Session-and-Token-Based-Authentication-Methods.png" style="height: 550px; width: 800px;">
				</section>
				<section>
					<section>
						<h4>Token-Based Authentication in nestjs</h4>
					</section>
					<section id="fragments">
						<p>Let's review and refine our requirements:</p>
						<p class="fragment">Allow users to authenticate with username/password, returning a JWT for use in subsequent calls to protected API endpoints. We're well on our way to meeting this requirement. To complete it, we'll need to write the code that issues a JWT.</p>
						<p class="fragment">Create API routes which are protected based on the presence of a valid JWT as a bearer token.</p>
					</section>
					<section>
						<p>We'll need to install a couple more packages to support our JWT requirements:</p>
						<p>npm install --save @nestjs/jwt passport-jwt</p>
						<p>npm install --save-dev @types/passport-jwt</p>
					</section>
					<section>
						<p>First we need to add the jwtService.sign() from @nestjs/jwt in the signin method </p>
						<p>For example: </p>
						<pre><code class="typescript-language" data-trim data-noescape>
							// auth/auth.service.ts
							async login(user: any) {
								const payload = { username: user.username, sub: user.userId };
								// validate username and password logic...
								return {
								  access_token: this.jwtService.sign(payload),
								};
							  }
						</code></pre>
					</section>
					<section>
						<p>the jwtService.sign() should be executed after the user has been validated </p>
					</section>
					<section>
						<p>next auth.module.ts in the auth folder and update it to look like this:</p>
						<pre><code class="typescript-language" data-trim data-noescape>
							//auth/auth.module.ts
							// imports...
							@Module({
							  imports: [
								UsersModule,
								PassportModule,
								JwtModule.register({
								  secret: 'some-secret-sould-be-from-consts-file',
								  signOptions: { expiresIn: '60s' },
								}),
							  ],
							  providers: [AuthService, LocalStrategy],
							  exports: [AuthService],
							})
							export class AuthModule {}
						</code></pre>
					</section>
					<section>
						<p>now we need to create a new file jwt.strategy.ts:</p>
						<pre><code class="typescript-language" data-trim data-noescape>
							//auth/jwt.strategy.ts
							// imports...
							@Injectable()
							export class JwtStrategy extends PassportStrategy(Strategy) {
							  constructor() {
								super({
								  jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
								  ignoreExpiration: false,
								  secretOrKey: 'some-secret-sould-be-from-consts-file',
								});
							  }
							
							  async validate(payload: any) {
								return { userId: payload.sub, username: payload.username };
							  }
							}
						</code></pre>
					</section>
					<section id="fragments">
						<p>For the jwt-strategy, Passport first verifies the JWT's signature and decodes the JSON. It then invokes our validate() method passing the decoded JSON as its single parameter. </p>
						<p class="fragment"> It's also worth pointing out that this approach leaves us room ('hooks' as it were) to inject other business logic into the process. For example, we could do a database lookup in our validate() method to extract more information about the user, resulting in a more enriched user object being available in our Request</p>
					</section>
					<section>
						<p>Add the new JwtStrategy as a provider in the AuthModule:</p>
						<pre><code class="typescript-language" data-trim data-noescape>
							// auth/auth.module.ts
							// imports...
							@Module({
								imports: [
								  UsersModule,
								  PassportModule,
								  JwtModule.register({
									secret: 'some-secret-sould-be-from-consts-file',
									signOptions: { expiresIn: '60s' },
								  }),
								],
								providers: [AuthService, LocalStrategy, JwtStrategy],
								exports: [AuthService],
							  })
							  export class AuthModule {}
						</code></pre>
						</section>
						<section>
							<p>By importing the same secret used when we signed the JWT, we ensure that the verify phase performed by Passport, and the sign phase performed in our AuthService, use a common secret.</p>
						</section>
						<section>
							<p> now we can use @UseGuards(AuthGuard())  from @nestjs/passport any where in the code and it will go through the process of: </p>
							<p> validate token (content and time) ->  go to the validate() method in the JwtStrategy, do it's logic and assingn it's return value to the req.user prop -> go to the controller method </p>
						</section>
						<section id="fragments">
							<p>For example:</p>
							<pre><code class="typescript-language" data-trim data-noescape>
								// app.controller.ts ...
								@UseGuards(AuthGuard())
								@Get('profile')
								getProfile(@Request() req) {
								  return req.user;
								}
							</code></pre>
							<p class="fragment">Pay attention - When our GET /profile route is hit, the Guard will automatically invoke our passport-jwt custom configured logic, validating the JWT, and assigning the user property to the Request object. </p>
						</section>
						<section>
							<p>Sometimes you have more than one jwt token (for example if you have access_token and refresh_token) so you can create a named token and mention the specific name in the auth guard</p>
						</section>
						<section>
							<pre><code class="typescript-language" data-trim data-noescape>
								// jwt.strategy.ts ...
								export class JwtStrategy extends PassportStrategy(Strategy, 'jwt') {
									code...
								}
						</code></pre>
						</section>
						<section>
							<p>option 1:</p>
							<pre><code class="typescript-language" data-trim data-noescape>
								// app.controller.ts ...
								@UseGuards(AuthGuard('jwt'))
								@Get('profile')
								getProfile(@Request() req) {
								  return req.user;
								}
							</code></pre>
						</section>
						<section>
							<p>option 2:</p>
							<pre><code class="typescript-language" data-trim data-noescape>
								//auth/jwt-auth.guard.ts
								// imports...								
								@Injectable()
								export class JwtAuthGuard extends AuthGuard('jwt') {}
							</code></pre>
							<pre><code class="typescript-language" data-trim data-noescape>
								// app.controller.ts
								// imports...								
								@UseGuards(JwtAuthGuard)
								@Get('profile')
								getProfile(@Request() req) {
								  return req.user;
								}
							</code></pre>
						</section>
					</section>
				</section>
			</div>
		</div>

		<script src="../../dist/reveal.js"></script>
		<script src="../../plugin/notes/notes.js"></script>
		<script src="../../plugin/markdown/markdown.js"></script>
		<script src="../../plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
