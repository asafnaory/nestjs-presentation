<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="../../dist/reset.css">
		<link rel="stylesheet" href="../../dist/reveal.css">
		<link rel="stylesheet" href="../../dist/theme/black.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="../../plugin/highlight/monokai.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
			<section>
				Advenced typing
			</section>
			<section>
				<div style="display: flex; flex-direction: column; justify-content: center;">
					<h4>Part 1: Utility Types</h4>
					<p>TypeScript provides several utility types to facilitate common type transformations. These utilities are available globally.</p>
				</div>
			</section>
				<section id="fragments">
					<section>
						Partial Type
						<p>Constructs a type with all properties of Type set to optional. This utility will return a type that represents all subsets of a given type.</p>
					</section>
					<section>
						<p>for example - consider this interface </p>
						<pre class="fragment" data-id="code-animation" ><code class="hljs">	<script type="text/template">
							interface Todo {
								title: string;
								description: string;
							  }
						  </script></code></pre>
					</section>
					<section>
						<p>Lets say I want to create a function that updates a todo  </p>
						<p class="fragment">I can pass to this function also a partial type:</p>
						<pre class="fragment" data-id="code-animation" ><code class="hljs">	<script type="text/template">
							const todo1 = {
								title: "organize desk",
								description: "clear clutter",
							  };
							   
							  const todo2 = updateTodo(todo1, {
								description: "throw out trash",
							  });
						  </script></code></pre>
					</section>
				</section>
					<section id="fragments">
					<section>
						Required Type
						<p>Constructs a type consisting of all properties of Type set to required. The opposite of Partial.</p>
					</section>
					<section>
						<p>Consider the next example:</p>
						<pre class="fragment" data-id="code-animation" ><code class="hljs">	<script type="text/template">
							interface Props {
								a?: number;
								b?: string;
							  }
						  </script></code></pre>
					</section>
					<section>
						<pre  data-id="code-animation" ><code class="hljs">	<script type="text/template">
							const obj: Props = { a: 5 };
 
							const obj2: Required<Props> = { a: 5 };
						  </script></code></pre>
						  <p class="fragment"> This is an error!</p>
					</section>
				</section>
				<section id="fragments">
					<section>
						Readonly Type
						<p>Constructs a type with all properties of Type set to readonly, meaning the properties of the constructed type cannot be reassigned.</p>
						<p>This utility is useful for representing assignment expressions that will fail at runtime (i.e. when attempting to reassign properties of a frozen object).</p>
					</section>
					<section id="fragments">
						<p>Example:</p>
						<pre data-id="code-animation" ><code class="hljs">	<script type="text/template">
							interface Todo {
								title: string;
							  }
							   
							  const todo: Readonly<Todo> = {
								title: "Delete inactive users",
							  };
							   
							  todo.title = "Hello";
						  </script></code></pre>
						  <p class="fragment">Error: Cannot assign to 'title' because it is a read-only property.</p>
					</section>
				</section>
				<section id="fragments">
					<section>
						Record
						<p>Constructs an object type whose property keys are Keys and whose property values are Type. This utility can be used to map the properties of a type to another type.</p>
						<p> the Record type is not identical to the index signature <pre><code class="typescript-language" data-trim data-noescape> [name: string]: number; </code></pre>
					</section>
					<section>
						<p>we can not use a Union type to describe an index signature key </p>
							<pre><code class="typescript-language" data-trim data-noescape> 
								[name: string | number]: number;
								[name: "key1" | "key2"]: number;
							</code></pre>
							<p>howerver we can do it in Recored Type</p>
					</section>
				</section>
				<section>
					Pick
					<p>Constructs a type by picking the set of properties Keys (string literal or union of string literals) from Type.</p>
				</section>
				<section>
					Omit
					<p>Constructs a type by picking all properties from Type and then removing Keys (string literal or union of string literals).</p>
				</section>

				<section>
					Exclude
					<p>Constructs a type by excluding from UnionType all union members that are assignable to ExcludedMembers.</p>
				</section>
				<section>
					Extract
					<p>Constructs a type by extracting from Type all union members that are assignable to Union.</p>
				</section>
				<section>Demo</section>
				<section>
					NonNullable
					<p>Constructs a type by excluding null and undefined from Type.</p>
				</section>
				<section>Demo</section>
				<section>
					Parameters
					<p>Constructs a tuple type from the types used in the parameters of a function type Type.</p>
				</section>
				<section>Demo</section>
				<section>
					ConstructorParameters
					<p>Constructs a tuple or array type from the types of a constructor function type. It produces a tuple type with all the parameter types (or the type never if Type is not a function).</p>
				</section>
					<section>Demo</section>
					<section>
					ReturnType					
					<p>Constructs a type consisting of the return type of function Type.</p>
				</section>
				<section>Demo</section>
				<section>
					InstanceType
					<p>Constructs a type consisting of the instance type of a constructor function in Type.</p>
				</section>
				<section>Demo</section>
				<section>
					ThisParameterType
					<p>Extracts the type of the this parameter for a function type, or unknown if the function type has no this parameter.</p>
				</section>
				<section>Demo</section>
			</section>
			<section>
				<div style="display: flex; flex-direction: column; justify-content: center;">
					<h4>Part 2: Creating Types from Types</h4>
					<p>TypeScript’s type system is very powerful because it allows expressing types in terms of other types.</p>
					<p>we alredy learned about generics, lets dive in into some more conceps</p>
				</div>
			</section>
			<section id="fragments">
				<ul>
					<li>1. Keyof Type Operator - Using the keyof operator to create new types</li>
					<li class="fragment">2. Typeof Type Operator - Using the typeof operator to create new types</li>
					<li class="fragment">3. Indexed Access Types - Using Type['a'] syntax to access a subset of a type</li>
					<li class="fragment">4. Conditional Types - Types which act like if statements in the type system</li>
					<li class="fragment">5. Mapped Types - Creating types by mapping each property in an existing type</li>
					<li class="fragment">6. Template Literal Types - Mapped types which change properties via template literal strings</li>
				</ul>
			</section>
			<section>
				<section>
				<p> Keyof Type Operator </p>	
			</section>
			<section>
				<p>The keyof operator takes an object type and produces a string or numeric literal union of its keys. The following type P is the same type as “x” | “y”</p>
			</section>
			<section id="fragments">
				<pre data-id="code-animation" ><code class="hljs">	<script type="text/template">
					type Point = { x: number; y: number };
					type P = keyof Point;
				  </script></code></pre>
				  <p class="fragment"> type P = keyof Point </p>
				  <p class="fragment"> type P = “x” | “y”: </p>
			</section>
			<section>
				<pre data-id="code-animation" ><code class="hljs">	<script type="text/template">
					type Mapish = { [k: string]: boolean };
					type M = keyof Mapish;
				  </script></code></pre>
				  <p class="fragment"> type M = string | number </p>
				  <p class="fragment">Note that in this example, M is string | number — this is because JavaScript object keys are always coerced to a string, so obj[0] is always the same as obj["0"].</p>
			</section>
			</section>
			<section>
			<section id="fragments">
					<p>Typeof Type Operator</p>	
				</section>
				<section>
					JavaScript already has a typeof operator you can use in an expression context:
				</section>
				<section>
					<pre><code>
						console.log(typeof "Hello world");
					</code></pre>
					<p class="fragment">What will be printed?</p>
				</section>
				<section>
					TypeScript adds a typeof operator you can use in a type context to refer to the type of a variable or property:
				</section>
				<section>
					<pre><code>
						let s = "hello";
						let n: typeof s;
						   
						let n: string
					</code>
					</pre>
				</section>
				<section>
					<pre data-id="code-animation" ><code class="hljs">	<script type="text/template">
						function f() {
							return { x: 10, y: 3 };
						  }
						  type P = ReturnType<typeof f>;
					</script></code></pre>
					<p class="fragment">What will be that type of P? </p>
				</section>
				<section>
					<div>
						type P = {
							x: number;
							y: number;
						}
					</div>
				</section>
			</section>
			<section>
			<section>
			<p> Indexed Access Types </p>	
			</section>
			<section id="fragments">
			<p>We can use an indexed access type to look up a specific property on another type:</p>
			<pre class="fragment" data-id="code-animation" ><code class="hljs">	<script type="text/template">
			type Person = { age: number; name: string; alive: boolean };
			type Age = Person["age"];
			</script></code></pre>
			<p class="fragment">
				type Age = number
			</p>
			</section>
			<section id="fragments">
			<pre data-id="code-animation" ><code class="hljs">	<script type="text/template">
				type I1 = Person["age" | "name"];
			</script></code></pre>
			<p class="fragment">
				type I1 = string | number
			</p>
			<pre class="fragment" data-id="code-animation" ><code class="hljs">	<script type="text/template">
				type I2 = Person[keyof Person];
			</script></code></pre>
			<p class="fragment">
				type I2 = string | number | boolean
			</p>
			<pre class="fragment" data-id="code-animation" ><code class="hljs">	<script type="text/template">
				type AliveOrName = "alive" | "name";
				type I3 = Person[AliveOrName];
			</script></code></pre>
			<p class="fragment">
				type I3 = string | boolean
			</p>					 
			</section>
			<section id="fragments">
				<p>Another example of indexing with an arbitrary type is using number to get the type of an array’s elements. We can combine this with typeof to conveniently capture the element type of an array literal:				</p>
			<pre  class="fragment" data-id="code-animation" ><code class="hljs">	<script type="text/template">
				const MyArray = [
				{ name: "Alice", age: 15 },
				{ name: "Bob", age: 23 },
				{ name: "Eve", age: 38 },
				];
			</script></code></pre>
			<pre  class="fragment" data-id="code-animation" ><code class="hljs">	<script type="text/template">
				type Person = typeof MyArray[number];
			</script></code></pre>
			<p class="fragment"> 
				type Person = {
					name: string;
					age: number;
				}
			</p>
			</section>
			<section id="fragments">
			<pre class="fragment" data-id="code-animation" ><code class="hljs">	<script type="text/template">
				type Age = typeof MyArray[number]["age"];
			</script></code></pre>
			<p class="fragment">type Age = number</p>
			<pre class="fragment" data-id="code-animation" ><code class="hljs">	<script type="text/template">
				type Age2 = Person["age"];
			</script></code></pre>
			<p class="fragment">type Age2 = number</p>
			</section>
			<section id="fragments">
			<p>You can only use types when indexing, meaning you can’t use a const to make a variable reference:</p>
			<pre class="fragment" data-id="code-animation" ><code class="hljs">	<script type="text/template">
				const key = "age";
				type Age = Person[key];
			</script></code></pre>
			<p class="fragment">
				Type 'key' cannot be used as an index type.
				'key' refers to a value, but is being used as a type here. Did you mean 'typeof key'?
			</p>
			</section>
			<section id="fragments"> 
				<p>However, you can use a type alias for a similar style of refactor:				</p>
			<pre class="fragment" data-id="code-animation" ><code class="hljs">	<script type="text/template">
				type key = "age";
				type Age = Person[key];
			</script></code></pre>
			</section>
			</section>
			<section>
				<section>
					<p> Conditional Types </p>
					<p> Conditional types help describe the relation between the types of inputs and outputs.</p>
				</section>
				<section id="fragments">
					<p>Consider the next example: </p>
					<pre class="fragment" data-id="code-animation" ><code class="hljs">	<script type="text/template">
						interface Animal {
							live(): void;
						  }
						  interface Dog extends Animal {
							woof(): void;
						  }
					</script></code></pre>
				</section>
				<section>
					<pre data-id="code-animation" ><code class="hljs">	<script type="text/template">
						type Example1 = Dog extends Animal ? number : string;
					</script></code></pre>
					<p class="fragment">type Example1 = number</p>
				</section>
				<section>
					<pre data-id="code-animation" ><code class="hljs">	<script type="text/template">
						type Example2 = RegExp extends Animal ? number : string;
					</script></code></pre>
					<p class="fragment">type Example2 = string</p>
				</section>
				<section>
					<p>Conditional types take a form that looks a little like conditional expressions (condition ? trueExpression : falseExpression) in JavaScript:</p>
					<p class="fragment">SomeType extends OtherType ? TrueType : FalseType;</p>
				</section>
				<section>
					<p>Quiz: https://dd.engineering/quiz/FuLTCD8u-7X_</p>
				</section>
			</section>
			<section>
				<section>Mapped Types </section>
				<section> 
					<p> When you don’t want to repeat yourself, sometimes a type needs to be based on another type. </p>
				</section>
				<section> 
					<p>A mapped type is a generic type which uses a union of PropertyKeys (frequently created via a keyof) to iterate through keys to create a type:</p>
					<pre class="fragment" data-id="code-animation" ><code class="hljs">	<script type="text/template">
						type OptionsFlags<Type> = {
							[Property in keyof Type]: boolean;
						  };
					</script></code></pre>
					<p class="fragment"> In this example, OptionsFlags will take all the properties from the type Type and change their values to be a boolean.</p>
				</section>
				<section>
					<p>for example: </p>
					<pre class="fragment" data-id="code-animation" ><code class="hljs">	<script type="text/template">
					type FeatureFlags = {
						darkMode: () => void;
						newUserProfile: () => void;
					  };
					   
					  type FeatureOptions = OptionsFlags<FeatureFlags>;
					</script></code></pre>
					<p class="fragment">What is the type of FeatureOptions?</p>
					<div class="fragment">
						type FeatureOptions = {
							darkMode: boolean;
							newUserProfile: boolean;
						}
					</div>
				</section>
				<section>
				 <p> Assignment: </p>	
				 <p> 1. Create a generic type that receives a type and returns the same type </p>	
				 <p> 2. Create a generic type that receives a type and returns the same type but with all its keys as optional </p>	
				 <p> 3. Create a generic type that receives a type and returns the same type but with all its keys as nullable </p>	
				 <p> 5. Create a generic type that receives 2 types and returns only the keys that are in both </p>	
				 <p> 6. Create a generic type that receives 2 types and returns the first type as the types keys and the second type as the types value</p>	
					 
				</section>
			</section>
			<section>
			<section>Template Literal Types </section>
			</div>
		</div>

		<script src="../../dist/reveal.js"></script>
		<script src="../../plugin/notes/notes.js"></script>
		<script src="../../plugin/markdown/markdown.js"></script>
		<script src="../../plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>



<!-- <pre class="fragment" data-id="code-animation" ><code class="hljs">	<script type="text/template">
				
</script></code></pre> -->