<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="../../dist/reset.css">
		<link rel="stylesheet" href="../../dist/reveal.css">
		<link rel="stylesheet" href="../../dist/theme/black.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="../../plugin/highlight/monokai.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section> Other Building Blocks </section>
                <section>
                    <section>
                        Middleware
                    </section>
                </section> 
                <section>
                    <section>
                        Exception filters
                    </section>
					<section>
						<p>Nest comes with a built-in exceptions layer which is responsible for processing all unhandled exceptions across an application. When an exception is not handled by your application code, it is caught by this layer, which then automatically sends an appropriate user-friendly response.</p>
					</section>
					<section>
						<img src="../../assets/exeption-filters.png" style="height: 500px; width: 1000px;">
					</section>
					<section>
						<p>Out of the box, this action is performed by a built-in global exception filter, which handles exceptions of type HttpException (and subclasses of it). When an exception is unrecognized (is neither HttpException nor a class that inherits from HttpException), the built-in exception filter generates the following default JSON response.</p>
					</section>
					<section>
						<pre><code class="typescript-language" data-trim data-noescape>
							{
								"statusCode": 500,
								"message": "Internal server error"
							  }
						</code></pre>
					</section>
					<section>
						<pre><code class="typescript-language" data-trim data-noescape data-line-numbers="3">
							@Get()
							async findAll() {
							  throw new HttpException('Forbidden', HttpStatus.FORBIDDEN);
							}
						</code></pre>
					</section>
					<section>
						<pre><code class="typescript-language" data-trim data-noescape>
							{
								"statusCode": 403,
								"message": "Forbidden"
							  }
						</code></pre>
					</section>
					<section>
						<pre><code class="typescript-language" data-trim data-noescape data-line-numbers="3-6">
							@Get()
							async findAll() {
							  throw new HttpException({
								status: HttpStatus.FORBIDDEN,
								error: 'This is a custom message',
							  }, HttpStatus.FORBIDDEN);
							}
						</code></pre>
					</section>
					<section>
						<img src="../../assets/costume-exeptions.png" style="height: 500px; width: 1000px;">
					</section>
					<section>
						<pre><code class="typescript-language" data-trim data-noescape data-line-numbers="3">
							@Get()
							async findAll() {
							  throw new ForbiddenException();
							}
						</code></pre>
					</section>
					<section>
						<p>Exception filters</p>
					</section>
					<section>
						<p>While the base (built-in) exception filter can automatically handle many cases for you, you may want full control over the exceptions layer. For example, you may want to add logging or use a different JSON schema based on some dynamic factors. Exception filters are designed for exactly this purpose. They let you control the exact flow of control and the content of the response sent back to the client</p>
					</section>
					<section>
						<pre><code class="typescript-language" data-trim data-noescape>
							import { ExceptionFilter, Catch, ArgumentsHost, HttpException } from '@nestjs/common';
							import { Request, Response } from 'express';
							
							@Catch(HttpException)
							export class HttpExceptionFilter implements ExceptionFilter {
							  catch(exception: HttpException, host: ArgumentsHost) {
								const ctx = host.switchToHttp();
								const response = ctx.getResponse<Response>();
								const request = ctx.getRequest<Request>();
								const status = exception.getStatus();
							
								response
								  .status(status)
								  .json({
									statusCode: status,
									timestamp: new Date().toISOString(),
									path: request.url,
								  });
							  }
							}
						</code></pre>
					</section>
                </section> 
                <section>
                    <section>
                        Pipes
                    </section>
                </section> 
                <section>
                    <section>
                        Guards
                    </section>
                </section> 
                <section>
                    <section>
                        Interceptors
                    </section>
                </section> 
                <section>
                    <section>
                        Custom decorators
                    </section>
                </section> 
			</div>
		</div>

		<script src="../../dist/reveal.js"></script>
		<script src="../../plugin/notes/notes.js"></script>
		<script src="../../plugin/markdown/markdown.js"></script>
		<script src="../../plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
