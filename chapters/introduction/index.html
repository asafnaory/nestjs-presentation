<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <title>reveal.js</title>

    <link rel="stylesheet" href="../../dist/reset.css" />
    <link rel="stylesheet" href="../../dist/reveal.css" />
    <link rel="stylesheet" href="../../dist/theme/black.css" />

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="../../plugin/highlight/monokai.css" />

</head>
<style>
    .reveal {
        background-color: black
    }
</style>

<body>
    <div class="reveal">
        <div class="slides">
            <section>
                <p>What is nestjs?</p>
                <p>A progressive Node.js framework for building efficient, reliable and scalable server-side applications.</p>
            </section>

            <section id="fragments">
                <p>What are we going to learn?</p>
                <p class="fragment">1. Introduction and philosophy</p>
                <p class="fragment">3. Fundamentals - General architecture (modules ,Controllers Providers ) </p>
                <p class="fragment">4. Fundamentals -  Main features (Decorators ,Pipes, Exception, middleware)</p>
                <p class="fragment">5. Demo : simple CRUD </p>
                <p class="fragment">6. First exercise </p>
            </section>
            <section>
                <img src="../../assets/npm-trends.png" style="height: 650px; width: 1000px;">
            </section>
            <section  id="fragments" data-background-color="white" data-background-iframe="https://nestjs.com/" data-background-interactive>
            </section>
            <section id="fragments">
                <p>Why care about NestJS ? </p>
            </section>
            <section>
                <p>Typescript</p>
            </section>
            <section>
                <p>Dependency Injection</p>
            </section>
            <section>
                <p>Common used features abstractions</p>
                <p>Rest, GraphQL, websockets, event emmiter and more...</p>
            </section>
            <section>
                <p>Command line interface (CLI)</p>
            </section>
            <section>
                <p>Application architecture</p>
            </section>
            <section>
                <p>Fundamentals</p>
            </section>
            <section>

                <section>
                    <p>Modules</p>
                </section>
                <section>
                    <p>
                        A module is a class annotated with a @Module() decorator. The @Module() decorator provides metadata that Nest makes use of to organize the application structure.
                    </p>
                </section>
                <section>
                    <img src="../../assets/modules-nest.png" style="height: 650px; width: 1000px;">
                </section>
                <section id="fragments">
                    <p>Modules</p>
                    <p class="fragment"> Each application has at least one module, a root module </p>
                    <p class="fragment"> We want to emphasize that modules are strongly recommended as an effective way to organize your components </p>
                    <p class="fragment"> for most applications, the resulting architecture will employ multiple modules, each encapsulating a closely related set of capabilities. </p>
                </section>
                <section id="fragments">
                    <p> The @Module() decorator takes a single object whose properties describe the module</p>
                </section>
                <section>
                    <p> providers: the providers that will be instantiated by the Nest injector and that may be shared at least across this module </p>
                </section>
                <section>
                    <p> controllers: the set of controllers defined in this module which have to be instantiated</p>
                </section>
                <section>
                    <p> imports: the list of imported modules that export the providers which are required in this module </p>
                </section>
                <section>
                    <p> exports: the subset of providers that are provided by this module and should be available in other modules which import this module. You can use either the provider itself or just its token (provide value)</p>
                </section>
                <section id="fragments">
                    <p>Type of modules</p>
                    <p class="fragment">Feature modules</p>
                    <p class="fragment">Shared modules</p>
                    <p class="fragment">Global modules</p>
                    <p class="fragment">Dynamic modules</p>
                </section>
                <section>
                    <p>Feature modules</p>
                    <p class="fragment">A feature module simply organizes code relevant for a specific feature, keeping code organized and establishing clear boundaries.</p>
                    <p class="fragment">This helps us manage complexity and develop with SOLID principles, especially as the size of the application and/or team grow.</p>
                </section>
                <section>
                    <pre><code class="typescript-language" data-trim data-noescape>
                        import { Module } from '@nestjs/common';
                        import { CatsController } from './cats.controller';
                        import { CatsService } from './cats.service';
                        
                        @Module({
                          controllers: [CatsController],
                          providers: [CatsService],
                        })
                        export class CatsModule {}
                    </code></pre>
                </section>
                <section id="fragments">
                    <p>Shared modules</p>
                    <p class="fragment">In Nest, modules are singletons by default, and thus you can share the same instance of any provider between multiple modules effortlessly.</p>
                    <p class="fragment">Every module is automatically a shared module. Once created it can be reused by any module.</p>
                </section>
                <section>
                    <img src="../../assets/shared-module.png" style="height: 500px; width: 1000px;">
                </section>
                <section>
                    <pre><code class="typescript-language" data-trim data-noescape data-line-numbers="1-10 | 8">
                        import { Module } from '@nestjs/common';
                        import { CatsController } from './cats.controller';
                        import { CatsService } from './cats.service';
                        
                        @Module({
                          controllers: [CatsController],
                          providers: [CatsService],
                          exports: [CatsService]
                        })
                        export class CatsModule {}
                    </code></pre>
                </section>
                <section id="fragments">
                    <p>Global modules </p>
                    <p class="fragment">When you want to provide a set of providers which should be available everywhere out-of-the-box (e.g., helpers, database connections, etc.), make the module global with the @Global() decorator. </p>
                    <p class="fragment">The @Global() decorator makes the module global-scoped. Global modules should be registered only once, generally by the root or core module. In the above example, the CatsService provider will be ubiquitous, and modules that wish to inject the service will not need to import the CatsModule in their imports array </p>
                </section>
                <section>
                    <pre><code class="typescript-language" data-trim data-noescape data-line-numbers="1-10 | 5">
                        import { Module, Global } from '@nestjs/common';
                        import { CatsController } from './cats.controller';
                        import { CatsService } from './cats.service';
                        
                        @Global()
                        @Module({
                          controllers: [CatsController],
                          providers: [CatsService],
                          exports: [CatsService],
                        })
                        export class CatsModule {}
                    </code></pre>
                </section>
                <section id="fragments">
                    <p>Dynamic modules</p>
                    <p class="fragment">This feature enables you to easily create customizable modules that can register and configure providers dynamically. </p>
                </section>
                <section>
                    <pre><code class="typescript-language" data-trim data-noescape>
                        import { Module, DynamicModule } from '@nestjs/common';
                        import { createDatabaseProviders } from './database.providers';
                        import { Connection } from './connection.provider';
                        
                        @Module({
                          providers: [Connection],
                        })
                        export class DatabaseModule {
                          static forRoot(entities = [], options?): DynamicModule {
                            const providers = createDatabaseProviders(options, entities);
                            return {
                              module: DatabaseModule,
                              providers: providers,
                              exports: providers,
                            };
                          }
                        }
                    </code></pre>
                </section>
            </section>
            <section>
                <section>
                    <p>Controllers</p>
                </section>
                <section id="fragments">
                    <p>Controllers are responsible for handling incoming requests and returning responses to the client.</p>
                    <p class="fragment">A controller's purpose is to receive specific requests for the application. The routing mechanism controls which controller receives which requests. Frequently, each controller has more than one route, and different routes can perform different actions.</p>
                    <p class="fragment">In order to create a basic controller, we use classes and decorators. Decorators associate classes with required metadata and enable Nest to create a routing map (tie requests to the corresponding controllers).</p>
                </section>
                <section>
                        <img src="../../assets/controller.png" style="height: 500px; width: 1000px;">
                </section>
                <section>
                    <pre><code class="typescript-language" data-trim data-noescape data-line-numbers="1-8 | 2 | 4 |5-7">
                        import { Controller, Get, Req } from '@nestjs/common';
                        import { Request } from 'express';
                        
                        @Controller('cats')
                        export class CatsController {
                          @Get()
                          findAll(@Req() request: Request): string {
                            return 'This action returns all cats';
                          }
                        }
                    </code></pre>
                </section>
                <section>
                    <img src="../../assets/decorators.png" style="height: 500px; width: 1000px;">
                </section>
            </section>
            <section>
                <section>
                    <p>Providers</p>
                </section>
                <section>
                    <p>Providers are a fundamental concept in Nest. Many of the basic Nest classes may be treated as a provider – services, repositories, factories, helpers, and so on. The main idea of a provider is that it can be injected as a dependency; this means objects can create various relationships with each other, and the function of "wiring up" instances of objects can largely be delegated to the Nest runtime system.</p>
                </section>
                <section>
                    <img src="../../assets/providers.png" style="height: 500px; width: 1000px;">
                </section>
                <section>
                    <p>Services</p>
                </section>
                <section id="fragments">
                    <p>A service is the most common use of providers. </p>
                    <p class="fagment">Every controller has a service</p>
                    <p class="fagment">All the business logic should be in the service and the controller should stay as lean as possible </p>
                </section>
                <section>
                    <pre><code class="typescript-language" data-trim data-noescape>
                        import { Injectable } from '@nestjs/common';
                        import { Cat } from './interfaces/cat.interface';
                        
                        @Injectable()
                        export class CatsService {
                          private readonly cats: Cat[] = [];
                        
                          create(cat: Cat) {
                            this.cats.push(cat);
                          }
                        
                          findAll(): Cat[] {
                            return this.cats;
                          }
                        }
                    </code></pre>
                </section>
                <section id="fragments">
                    <p>Dependency Injection</p>
                    <p class="fragment">
                        In Nest, thanks to TypeScript capabilities, it's extremely easy to manage dependencies because they are resolved just by type. In the example below, Nest will resolve the catsService by creating and returning an instance of CatsService (or, in the normal case of a singleton, returning the existing instance if it has already been requested elsewhere). This dependency is resolved and passed to your controller's constructor (or assigned to the indicated property)
                    </p>
                </section>
            </section>
        </div>
    </div>
    <script src="../../dist/reveal.js"></script>
    <script src="../../plugin/notes/notes.js"></script>
    <script src="../../plugin/markdown/markdown.js"></script>
    <script src="../../plugin/highlight/highlight.js"></script>
    <script>
        // More info about initialization & config:
        // - https://revealjs.com/initialization/
        // - https://revealjs.com/config/
        Reveal.initialize({
            hash: true,

            // Learn about plugins: https://revealjs.com/plugins/
            plugins: [RevealMarkdown, RevealHighlight, RevealNotes],
        });
    </script>
</body>

</html>